/**
 * Vibe Science v6.0 NEXUS — sqlite-vec Wrapper for Semantic Search
 *
 * Provides vector similarity search over memory embeddings using sqlite-vec,
 * with graceful fallback to full-text LIKE queries when the extension is
 * unavailable or no embeddings exist yet.
 *
 * The actual embedding computation is performed by the worker process.
 * This module only QUERIES the vec_memories virtual table (or falls back
 * to a text search on embed_queue / narrative summaries).
 *
 * Export: vecSearch, queueForEmbedding
 */

// =====================================================
// Helpers
// =====================================================

/**
 * Check whether the sqlite-vec extension has been loaded and
 * the vec_memories virtual table exists in the given database.
 *
 * @param {import('better-sqlite3').Database} db
 * @returns {boolean}
 */
function isVecAvailable(db) {
    try {
        // sqlite_master will contain the virtual table entry if it was created
        const row = db.prepare(
            `SELECT name FROM sqlite_master
             WHERE type = 'table' AND name = 'vec_memories'`
        ).get();
        return !!row;
    } catch {
        return false;
    }
}

/**
 * Count the rows currently stored in vec_memories.
 *
 * @param {import('better-sqlite3').Database} db
 * @returns {number}
 */
function vecRowCount(db) {
    try {
        const row = db.prepare(`SELECT COUNT(*) AS cnt FROM vec_memories`).get();
        return row?.cnt ?? 0;
    } catch {
        return 0;
    }
}

// =====================================================
// Core search
// =====================================================

/**
 * Search memory embeddings for texts semantically similar to `queryText`.
 *
 * Strategy:
 *   1. If vec_memories exists AND contains rows, attempt a vector query.
 *      (Requires the caller to have already loaded the sqlite-vec extension
 *       and to supply a pre-computed query embedding — see options.queryEmbedding.)
 *      NOTE: In practice the embedding is generated by the worker.  When no
 *      queryEmbedding is provided we skip the vector path and go to step 2.
 *   2. Fall back to a keyword-based LIKE search over narrative summaries
 *      stored in the sessions table and any already-embedded text in
 *      vec_memories (via its +text auxiliary column).
 *
 * @param {import('better-sqlite3').Database} db
 * @param {string} queryText - Natural language query
 * @param {object} [options]
 * @param {string}  [options.project_path]  - Limit results to a project
 * @param {number}  [options.limit=3]       - Max results to return
 * @param {number}  [options.maxTokens=500] - Soft cap on combined text length (chars / 4)
 * @param {Float32Array} [options.queryEmbedding] - Pre-computed 384-dim vector
 * @returns {Array<{text: string, distance: number|null, metadata: object|null}>}
 */
export function vecSearch(db, queryText, options = {}) {
    const limit = options.limit ?? 3;
    const maxTokens = options.maxTokens ?? 500;
    const projectPath = options.project_path ?? null;

    // -----------------------------------------------------------------
    // Path A: true vector search (if vec extension loaded + embeddings exist
    //         + caller provided the query embedding)
    // -----------------------------------------------------------------
    if (options.queryEmbedding && isVecAvailable(db) && vecRowCount(db) > 0) {
        try {
            return vectorQuery(db, options.queryEmbedding, projectPath, limit, maxTokens);
        } catch {
            // If vector query fails for any reason, fall through to text fallback
        }
    }

    // -----------------------------------------------------------------
    // Path B: text-based fallback
    // -----------------------------------------------------------------
    return textFallback(db, queryText, projectPath, limit, maxTokens);
}

// =====================================================
// Vector query (requires sqlite-vec + query embedding)
// =====================================================

/**
 * Execute the actual sqlite-vec nearest-neighbor query.
 *
 * sqlite-vec syntax:
 *   SELECT rowid, distance FROM vec_memories
 *   WHERE embedding MATCH ? ORDER BY distance LIMIT ?
 *
 * The auxiliary columns (+text, +metadata, +project_path) are fetched
 * via a second lookup by rowid since vec0 tables do not return them
 * directly from the MATCH query in all versions.
 *
 * @param {import('better-sqlite3').Database} db
 * @param {Float32Array} embedding - 384-dimensional float32 array
 * @param {string|null} projectPath
 * @param {number} limit
 * @param {number} maxTokens
 * @returns {Array<{text: string, distance: number, metadata: object|null}>}
 */
function vectorQuery(db, embedding, projectPath, limit, maxTokens) {
    // sqlite-vec expects the embedding as a raw Buffer of float32 values
    const buf = Buffer.from(embedding.buffer, embedding.byteOffset, embedding.byteLength);

    // Fetch more than needed so we can filter by project_path afterwards
    const fetchLimit = projectPath ? limit * 3 : limit;

    const matchRows = db.prepare(
        `SELECT rowid, distance FROM vec_memories
         WHERE embedding MATCH ?
         ORDER BY distance
         LIMIT ?`
    ).all(buf, fetchLimit);

    if (matchRows.length === 0) {
        return [];
    }

    // Fetch the auxiliary columns for the matched rowids
    const placeholders = matchRows.map(() => '?').join(',');
    const auxRows = db.prepare(
        `SELECT rowid, text, metadata, project_path
         FROM vec_memories
         WHERE rowid IN (${placeholders})`
    ).all(...matchRows.map(r => r.rowid));

    // Index by rowid for fast lookup
    const auxMap = new Map();
    for (const row of auxRows) {
        auxMap.set(row.rowid, row);
    }

    // Merge, filter, truncate
    const results = [];
    let tokenBudget = maxTokens;

    for (const match of matchRows) {
        if (tokenBudget <= 0) break;

        const aux = auxMap.get(match.rowid);
        if (!aux) continue;

        // Filter by project_path when specified
        if (projectPath && aux.project_path !== projectPath) continue;

        const textLen = aux.text?.length ?? 0;
        const estimatedTokens = Math.ceil(textLen / 4);

        let parsedMeta = null;
        if (aux.metadata) {
            try { parsedMeta = JSON.parse(aux.metadata); } catch { /* ignore */ }
        }

        results.push({
            text: aux.text ?? '',
            distance: match.distance,
            metadata: parsedMeta
        });

        tokenBudget -= estimatedTokens;

        if (results.length >= limit) break;
    }

    return results;
}

// =====================================================
// Text fallback (LIKE-based)
// =====================================================

/**
 * When sqlite-vec is not available (or no embeddings exist yet), fall back
 * to a simple keyword search.  We search:
 *   1. vec_memories.text (if the table exists but we lack a query vector)
 *   2. sessions.narrative_summary for the project
 *
 * Keywords are extracted from queryText by splitting on whitespace and
 * filtering out very short words.
 *
 * @param {import('better-sqlite3').Database} db
 * @param {string} queryText
 * @param {string|null} projectPath
 * @param {number} limit
 * @param {number} maxTokens
 * @returns {Array<{text: string, distance: number|null, metadata: object|null}>}
 */
function textFallback(db, queryText, projectPath, limit, maxTokens) {
    const keywords = extractKeywords(queryText);
    if (keywords.length === 0) {
        return [];
    }

    const results = [];
    let tokenBudget = maxTokens;

    // --- Source 1: vec_memories text column (if table exists) ---
    if (isVecAvailable(db)) {
        try {
            const likeClause = keywords.map(() => 'text LIKE ?').join(' OR ');
            const params = keywords.map(k => `%${k}%`);

            if (projectPath) {
                params.push(projectPath);
            }

            const sql = projectPath
                ? `SELECT text, metadata FROM vec_memories
                   WHERE (${likeClause}) AND project_path = ?
                   ORDER BY created_at DESC LIMIT ?`
                : `SELECT text, metadata FROM vec_memories
                   WHERE (${likeClause})
                   ORDER BY created_at DESC LIMIT ?`;

            params.push(limit);

            const rows = db.prepare(sql).all(...params);
            for (const row of rows) {
                if (tokenBudget <= 0 || results.length >= limit) break;

                let parsedMeta = null;
                if (row.metadata) {
                    try { parsedMeta = JSON.parse(row.metadata); } catch { /* ignore */ }
                }

                results.push({
                    text: row.text ?? '',
                    distance: null,     // no distance score in text mode
                    metadata: parsedMeta
                });
                tokenBudget -= Math.ceil((row.text?.length ?? 0) / 4);
            }
        } catch {
            // vec_memories may not support LIKE on auxiliary columns in
            // all sqlite-vec versions — silently fall through
        }
    }

    // --- Source 2: narrative summaries from sessions ---
    if (results.length < limit && tokenBudget > 0) {
        try {
            const likeClause = keywords.map(() => 'narrative_summary LIKE ?').join(' OR ');
            const params = keywords.map(k => `%${k}%`);

            if (projectPath) {
                params.push(projectPath);
            }

            const remaining = limit - results.length;
            params.push(remaining);

            const sql = projectPath
                ? `SELECT narrative_summary, id FROM sessions
                   WHERE (${likeClause}) AND project_path = ?
                   AND narrative_summary IS NOT NULL
                   ORDER BY ended_at DESC LIMIT ?`
                : `SELECT narrative_summary, id FROM sessions
                   WHERE (${likeClause})
                   AND narrative_summary IS NOT NULL
                   ORDER BY ended_at DESC LIMIT ?`;

            const rows = db.prepare(sql).all(...params);
            for (const row of rows) {
                if (tokenBudget <= 0 || results.length >= limit) break;

                results.push({
                    text: row.narrative_summary,
                    distance: null,
                    metadata: { session_id: row.id, source: 'narrative_summary' }
                });
                tokenBudget -= Math.ceil((row.narrative_summary?.length ?? 0) / 4);
            }
        } catch {
            // Table may not exist in a freshly created DB — ignore
        }
    }

    return results;
}

/**
 * Extract meaningful keywords from a query string.
 * Filters out words shorter than 3 characters and common stop words.
 *
 * @param {string} text
 * @returns {string[]}
 */
function extractKeywords(text) {
    const STOP_WORDS = new Set([
        'the', 'and', 'for', 'are', 'but', 'not', 'you', 'all',
        'can', 'had', 'her', 'was', 'one', 'our', 'out', 'has',
        'with', 'this', 'that', 'from', 'they', 'been', 'have',
        'its', 'will', 'each', 'make', 'than', 'them', 'into',
        'per', 'del', 'che', 'con', 'una', 'non', 'sono', 'come',
        'research', 'context', 'project'
    ]);

    return text
        .toLowerCase()
        .replace(/[^a-z0-9\s-]/g, ' ')
        .split(/\s+/)
        .filter(w => w.length >= 3 && !STOP_WORDS.has(w));
}

// =====================================================
// Embedding queue
// =====================================================

/**
 * Insert text into the embed_queue table for async processing by the worker.
 *
 * The worker process periodically polls embed_queue for rows where
 * processed = 0, computes embeddings (all-MiniLM-L6-v2), and inserts
 * the result into vec_memories.
 *
 * @param {import('better-sqlite3').Database} db
 * @param {string} text - Text to embed
 * @param {string|object} [metadata] - Arbitrary metadata (stored as JSON string)
 * @returns {import('better-sqlite3').RunResult}
 */
export function queueForEmbedding(db, text, metadata = null) {
    const meta = typeof metadata === 'object' && metadata !== null
        ? JSON.stringify(metadata)
        : metadata;

    return db.prepare(
        `INSERT INTO embed_queue (text, metadata, created_at)
         VALUES (?, ?, ?)`
    ).run(text, meta, new Date().toISOString());
}
